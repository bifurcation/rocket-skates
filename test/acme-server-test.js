// Copyright (c) 2016 the rocket-skates AUTHORS.  All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

'use strict';

const assert        = require('chai').assert;
const request       = require('supertest');
const urlParse      = require('url');
const MockClient    = require('./tools/mock-client');
const promisify     = require('./tools/promisify');
const AutoChallenge = require('./tools/auto-challenge');
//const ZeroChallenge = require('./tools/zero-challenge');
const jose          = require('../lib/jose');
const ACMEServer    = require('../lib/acme-server');

let serverConfig = {
  host:               '127.0.0.1',
  authzExpirySeconds: 30 * 24 * 3600,
  challengeTypes:     [AutoChallenge]
};
let mockClient = new MockClient();

// CSR generated by a Go script
// * Random public key
// * Two SANs:
//  * not-example.com
//  * www.not-example.com
let testCSR = 'MIICoTCCAYkCAQAwGjEYMBYGA1UEAxMPbm90LWV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq7F00dtBUeN9DHEiDRimh5OtlU0KDXw-B-04kBaZkTtXU-1G3GW-BG9p_M0PyT7NSn5rYcdzisajTQZJD-cQgltgevWARc8dkrIy4ogj4qihwagO-glAo20ZZoreibdL3cpOM2kmjRkkXDCFDXZF1kL8LhoKRg1H5dmkVcgw7ALr-AhRUHcvVmkv4XwGT_H1fzgutTCIMvEwnKIsn1lw6q5rK6pUktnsGQqJFrzJ_RUN_CK0BPg3BD9QOkwxXZ9ZTMttAIrZMuBA3wf_83_erI53s_46PMgLI3rDpPa9clqylSZGEDwXy8sLwQXSSuWCMLD_t99MZvDFcDjPSyJUaQIDAQABoEIwQAYJKoZIhvcNAQkOMTMwMTAvBgNVHREEKDAmgg9ub3QtZXhhbXBsZS5jb22CE3d3dy5ub3QtZXhhbXBsZS5jb20wDQYJKoZIhvcNAQEFBQADggEBAFoGL91KCrF1UaT-ZHOoC_SfXA9O2zsLHZDAqfcciqPn85pCUDntdbxiSAmfMt_K6PI-MqlWIR2ejZG7yYpT1Nx3UyDggRQiAS8WRPw8M9B43Ang5HnaOX2Y7q0J0TTGQXBO3Ts8advtQcvaOJMvpAborebQizzN0pzhMkBcAOgzZQVKWJvwqMzQsD5VJP8gw7i-HH3IROep3Ayu74gTDYvfVyMJEIbY1D4P3FcoUcc-K0mOYlIu1a8zS6KDCRj5rrhR1dmMj8bd_V6e9234lXHaZFTKDPcVowT8w9LwB4DJPzQu7b7grtynFV645q_-aSxPxJGmj7i-aayO-T00cUE';
let testCSRNames = ['not-example.com', 'www.not-example.com'];

class NotAChallenge {}

function path(url) {
  return urlParse.parse(url).path;
}

function registerKey(key, server) {
  let thumbprint;
  return key.thumbprint()
    .then(tpBuffer => {
      thumbprint = jose.base64url.encode(tpBuffer);
      let existing = {
        id:      thumbprint,
        key:     mockClient._key,
        contact: ['mailto:anonymous@example.com'],
        type:    function() { return 'reg'; },
        marshal: function() {
          return {
            key:       this.key.toJSON(),
            status:    this.status,
            contact:   this.contact,
            agreement: this.agreement
          };
        }
      };
      server.db.put(existing);
      return thumbprint;
    });
}

describe('ACME server', () => {
  it('refuses to create a server with no challenges', (done) => {
    try {
      new ACMEServer({challengeTypes: []});
      done(new Error('Created a server with a bogus challenge'));
    } catch (e) {
      done();
    }
  });

  it('refuses to create a server with bad challenges', (done) => {
    try {
      new ACMEServer({challengeTypes: [NotAChallenge]});
      done(new Error('Created a server with a bogus challenge'));
    } catch (e) {
      done();
    }
  });

  it('responds to a directory request', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';

    server.terms = termsURL;

    promisify(request(server.app).get('/directory'))
      .then(res => {
        assert.equal(res.status, 200);

        assert.property(res.headers, 'content-type');
        assert.include(res.headers['content-type'], 'application/json');

        assert.property(res.body, 'meta');
        assert.isObject(res.body.meta);
        assert.property(res.body.meta, 'terms-of-service');
        assert.equal(res.body.meta['terms-of-service'], termsURL);

        // Add things here as they get added to the directory
        assert.property(res.body, 'new-reg');
        assert.property(res.body, 'new-app');

        done();
      })
      .catch(done);
  });

  it('answers a valid fetch', (done) => {
    let server = new ACMEServer(serverConfig);
    let reg = {
      type:        function() { return 'foo'; },
      id:          'bar',
      marshal:     function() { return {baz: 42}; },
      contentType: function() { return 'application/json'; }
    };

    server.db.put(reg);
    promisify(request(server.app).get('/foo/bar'))
      .then(res => {
        assert.equal(res.status, 200);
        assert.deepEqual(res.body, reg.marshal());
        assert.property(res.headers, 'content-type');
        assert.include(res.headers['content-type'], 'application/json');
        done();
      })
      .catch(done);
  });

  it('rejects a fetch for a registration object', (done) => {
    let server = new ACMEServer(serverConfig);
    request(server.app)
      .get('/reg/foo')
      .expect(401, done);
  });

  it('rejects a fetch for a non-existent object', (done) => {
    let server = new ACMEServer(serverConfig);
    request(server.app)
      .get('/foo/bar')
      .expect(404, done);
  });

  it('creates a new registration', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';
    server.terms = termsURL;

    let nonce = server.transport.nonces.get();
    let url = server.baseURL + 'new-reg';
    let reg = {contact: ['mailto:anonymous@example.com']};
    let regPath;
    let created;

    let testServer = request(server.app);
    mockClient.makeJWS(nonce, url, reg)
      .then(jws => promisify(testServer.post('/new-reg').send(jws)))
      .then(res => {
        assert.equal(res.status, 201);
        assert.property(res.headers, 'content-type');
        assert.include(res.headers['content-type'], 'application/json');

        assert.property(res.headers, 'location');
        assert.property(res.headers, 'replay-nonce');
        assert.property(res.headers, 'link');

        created = res.body;
        assert.property(created, 'key');
        assert.property(created, 'contact');
        assert.deepEqual(created.key, mockClient._key.toJSON());
        assert.deepEqual(created.contact, reg.contact);

        regPath = path(res.headers.location);
        let newNonce = res.headers['replay-nonce'];
        return mockClient.makeJWS(newNonce, res.headers.location, {});
      })
      .then(jws => promisify(testServer.post(regPath).send(jws)))
      .then(res => {
        assert.equal(res.status, 200);
        assert.deepEqual(res.body, created);
        done();
      })
      .catch(done);
  });

  it('does a POST over a custom port', (done) => {
    let server = new ACMEServer({
      host:           '127.0.0.1',
      port:           8080,
      challengeTypes: [AutoChallenge]
    });
    let nonce = server.transport.nonces.get();
    let url = server.baseURL + 'new-reg';
    let reg = {contact: ['mailto:anonymous@example.com']};

    let testServer = request(server.app);
    mockClient.makeJWS(nonce, url, reg)
      .then(jws => promisify(testServer.post('/new-reg').send(jws)))
      .then(res => {
        assert.equal(res.status, 201);
        done();
      })
      .catch(done);
  });

  it('rejects a new registration for an existing key', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';
    server.terms = termsURL;

    let nonce = server.transport.nonces.get();
    let url = server.baseURL + 'new-reg';
    let reg = {contact: ['mailto:anonymous@example.com']};
    let jws;

    mockClient.makeJWS(nonce, url, reg)
      .then(signed => {
        jws = signed;
        return mockClient._key.thumbprint();
      })
      .then(tpBuffer => {
        let existing = {
          id:   jose.base64url.encode(tpBuffer),
          type: function() { return 'reg'; }
        };
        server.db.put(existing);

        request(server.app)
          .post('/new-reg')
          .send(jws)
          .expect(409)
          .expect('location', /.*/, done);
      });
  });

  it('updates a registration', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';
    server.terms = termsURL;

    let reg2 = {
      contact:   ['mailto:someone@example.com'],
      agreement: termsURL
    };
    let regThumbprint;

    mockClient.key()
      .then(k => registerKey(k, server))
      .then(thumbprint => {
        regThumbprint = thumbprint;
        let nonce = server.transport.nonces.get();
        let url = `${server.baseURL}reg/${regThumbprint}`;
        return mockClient.makeJWS(nonce, url, reg2);
      })
      .then(jws => promisify(request(server.app).post(`/reg/${regThumbprint}`).send(jws)))
      .then(res => {
        assert.equal(res.status, 200);

        assert.property(res.body, 'key');
        assert.property(res.body, 'contact');
        assert.property(res.body, 'agreement');

        assert.deepEqual(res.body.key, mockClient._key.toJSON());
        assert.deepEqual(res.body.contact, reg2.contact);
        assert.deepEqual(res.body.agreement, reg2.agreement);
        done();
      })
      .catch(done);
  });

  it('rejects a registration update to a non-existent registration', (done) => {
    let server = new ACMEServer(serverConfig);
    let nonce = server.transport.nonces.get();
    let url = `${server.baseURL}reg/non-existent`;

    mockClient.makeJWS(nonce, url, {})
      .then(jws => {
        return promisify(request(server.app).post('/reg/non-existent').send(jws));
      })
      .then(res => {
        assert.equal(res.status, 404);
        done();
      })
      .catch(done);
  });

  it('rejects a registration update with the wrong key', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';
    server.terms = termsURL;

    let regThumbprint;
    jose.newkey()
      .then(k => registerKey(k, server))
      .then(thumbprint => {
        regThumbprint = thumbprint;
        let url = `${server.baseURL}reg/${regThumbprint}`;
        let nonce = server.transport.nonces.get();
        return mockClient.makeJWS(nonce, url, {});
      })
      .then(jws => {
        return promisify(request(server.app).post(`/reg/${regThumbprint}`).send(jws));
      })
      .then(res => {
        assert.equal(res.status, 401);
        done();
      })
      .catch(done);
  });

  it('rejects a registration update with the wrong terms', (done) => {
    let server = new ACMEServer(serverConfig);
    let termsURL = 'https://example.com/terms';
    server.terms = termsURL;

    let regThumbprint;
    let reg2 = {
      contact:   ['mailto:someone@example.org'],
      agreement: termsURL + '-not!'
    };

    mockClient.key()
      .then(k => registerKey(k, server))
      .then(thumbprint => {
        regThumbprint = thumbprint;
        let nonce = server.transport.nonces.get();
        let url = `${server.baseURL}reg/${regThumbprint}`;
        return mockClient.makeJWS(nonce, url, reg2);
      })
      .then(jws => promisify(request(server.app).post(`/reg/${regThumbprint}`).send(jws)))
      .then(res => {
        assert.equal(res.status, 400);
        done();
      })
      .catch(done);
  });

  it('creates a new application', (done) => {
    let server = new ACMEServer(serverConfig);
    let app = {
      'csr':       testCSR,
      'notBefore': '2016-07-14T23:19:36.197Z',
      'notAfter':  '2017-07-14T23:19:36.197Z'
    };

    let testServer = request(server.app);
    mockClient.key()
      .then(k => registerKey(k, server))
      .then(() => {
        let nonce = server.transport.nonces.get();
        let url = server.baseURL + 'new-app';
        return mockClient.makeJWS(nonce, url, app);
      })
      .then(jws => promisify(testServer.post('/new-app').send(jws)))
      .then(res => {
        assert.equal(res.status, 201);

        assert.property(res.headers, 'location');

        assert.property(res.body, 'status');
        assert.property(res.body, 'csr');
        assert.property(res.body, 'notBefore');
        assert.property(res.body, 'notAfter');
        assert.property(res.body, 'requirements');

        assert.equal(res.body.csr, app.csr);
        assert.equal(res.body.notBefore, app.notBefore);
        assert.equal(res.body.notAfter, app.notAfter);
        assert.isArray(res.body.requirements);
        assert.isTrue(res.body.requirements.length > 0);

        let authz = res.body.requirements.map(req => {
          if (req.type !== 'authorization') {
            return Promise.resolve(false);
          }
          let authzPath = path(req.url);
          return promisify(testServer.get(authzPath));
        });
        return Promise.all(authz);
      })
      .then(responses => {
        let challengeTests = [];
        let authzNames = [];
        responses.map(res => {
          if (res == null) {
            return;
          }
          assert.equal(res.status, 200);

          assert.property(res.body, 'status');
          assert.property(res.body, 'expires');
          assert.property(res.body, 'identifier');
          assert.property(res.body, 'challenges');

          assert.isString(res.body.status);
          assert.isNotNaN((new Date(res.body.expires)).getTime());

          assert.property(res.body.identifier, 'type');
          assert.property(res.body.identifier, 'value');
          assert.propertyVal(res.body.identifier, 'type', 'dns');
          assert.isString(res.body.identifier.value);
          authzNames.push(res.body.identifier.value);

          assert.isArray(res.body.challenges);
          res.body.challenges.map(chall => {
            assert.isObject(chall);
            assert.property(chall, 'type');
            assert.property(chall, 'url');
            assert.isString(chall.type);
            assert.isString(chall.url);

            let challPath = path(chall.url);
            let test = promisify(testServer.get(challPath))
              .then(res2 => {
                assert.equal(res2.status, 200);
                assert.deepEqual(res2.body, chall);
              });
            challengeTests.push(test);
          });
        });

        assert.deepEqual(authzNames.sort(), testCSRNames.sort());
        return Promise.all(challengeTests);
      })
      .then(() => { done(); })
      .catch(done);
  });

  it('rejects a fetch to a bad challenge URL', (done) => {
    let server = new ACMEServer(serverConfig);
    let app = {
      'csr':       testCSR,
      'notBefore': '2016-07-14T23:19:36.197Z',
      'notAfter':  '2017-07-14T23:19:36.197Z'
    };

    let testServer = request(server.app);
    mockClient.key()
      .then(k => registerKey(k, server))
      .then(() => {
        let nonce = server.transport.nonces.get();
        let url = server.baseURL + 'new-app';
        return mockClient.makeJWS(nonce, url, app);
      })
      .then(jws => promisify(testServer.post('/new-app').send(jws)))
      .then(res => {
        assert.equal(res.status, 201);
        assert.equal(res.body.requirements[0].type, 'authorization');

        let badChallengePath = path(res.body.requirements[0].url) + '/42';
        return promisify(testServer.get(badChallengePath));
      })
      .then(res => {
        assert.equal(res.status, 404);
        done();
      })
      .catch(done);
  });

  it('rejects a new application from an unregistered key', (done) => {
    let server = new ACMEServer(serverConfig);

    let nonce = server.transport.nonces.get();
    let url = server.baseURL + 'new-app';

    let testServer = request(server.app);
    mockClient.makeJWS(nonce, url, {})
      .then(jws => {
        return promisify(testServer.post('/new-app').send(jws));
      })
      .then(res => {
        assert.equal(res.status, 401);
        done();
      })
      .catch(done);
  });

  function newAppError(app) {
    return (done) => {
      let server = new ACMEServer(serverConfig);
      let testServer = request(server.app);
      mockClient.key()
        .then(k => registerKey(k, server))
        .then(() => {
          let nonce = server.transport.nonces.get();
          let url = server.baseURL + 'new-app';
          return mockClient.makeJWS(nonce, url, app);
        })
        .then(jws => promisify(testServer.post('/new-app').send(jws)))
        .then(res => {
          assert.equal(res.status, 400);
          done();
        })
        .catch(done);
    };
  }

  it('rejects a new application with an no csr', newAppError({}));

  it('rejects a new application with an invalid csr', newAppError({
    csr: testCSR.substr(0, testCSR.length - 5)
  }));

  it('rejects a new application with an invalid notBefore', newAppError({
    csr:       testCSR,
    notBefore: 'not-a-date'
  }));

  it('rejects a new application with notAfter without notBefore', newAppError({
    csr:      testCSR,
    notAfter: 'not-a-date'
  }));

  it('rejects a new application with an invalid notAfter', newAppError({
    csr:       testCSR,
    notBefore: '2016-07-14T23:19:36.197Z',
    notAfter:  'not-a-date'
  }));

  it('rejects a new application with an excessive lifetime', newAppError({
    csr:       testCSR,
    notBefore: '2016-07-14T23:19:36.197Z',
    notAfter:  '2026-07-14T23:19:36.197Z'
  }));

  it('issues a certificate', function(done) {
    this.timeout(10000);

    let server = new ACMEServer(serverConfig);
    let app = {
      'csr':       testCSR,
      'notBefore': '2016-07-14T23:19:36.197Z',
      'notAfter':  '2017-07-14T23:19:36.197Z'
    };

    let appPath;
    let testServer = request(server.app);
    mockClient.key()
      .then(k => registerKey(k, server))
      .then(() => {
        let nonce = server.transport.nonces.get();
        let url = server.baseURL + 'new-app';
        return mockClient.makeJWS(nonce, url, app);
      })
      .then(jws => promisify(testServer.post('/new-app').send(jws)))
      .then(res => {
        assert.equal(res.status, 201);

        appPath = path(res.headers.location);

        let validations = res.body.requirements
          .filter(x => (x.type === 'authorization'))
          .map(req => {
            let authzPath = path(req.url);
            let challPath;

            return Promise.resolve()
              .then(() => promisify(testServer.get(authzPath)))
              .then(authzRes => {
                assert.equal(authzRes.status, 200);

                let challURL = authzRes.body.challenges[0].url;
                challPath = path(challURL);
                let challNonce = server.transport.nonces.get();
                return mockClient.makeJWS(challNonce, challURL, {
                  type:  AutoChallenge.type,
                  token: authzRes.body.challenges[0].token
                });
              })
              .then(jws =>  promisify(testServer.post(challPath).send(jws)))
              .then(challRes => assert.equal(challRes.status, 200))
              .then(() => promisify(testServer.get(authzPath)))
              .then(authzRes => {
                assert.equal(authzRes.status, 200);
                assert.equal(authzRes.body.status, 'valid');
              });
          });

        return Promise.all(validations);
      })
      .then(() => promisify(testServer.get(appPath)))
      .then(res => {
        assert.equal(res.status, 200);
        assert.equal(res.body.status, 'valid');
        assert.property(res.body, 'certificate');
        assert.isString(res.body.certificate);

        let certPath = path(res.body.certificate);
        return promisify(testServer.get(certPath));
      })
      .then(res => {
        assert.equal(res.status, 200);

        assert.property(res.headers, 'content-type');
        assert.include(res.headers['content-type'], 'application/pkix-cert');
        // XXX(#22): Test that the returned value is a valid certificate

        done();
      })
      .catch(done);
  });

  it('rejects an update to a non-existent authz', (done) => {
    let server = new ACMEServer(serverConfig);
    let nonce = server.transport.nonces.get();
    let url = server.baseURL + 'authz/bogus/0';
    let testServer = request(server.app);
    mockClient.makeJWS(nonce, url, {})
      .then(jws => promisify(testServer.post('/authz/bogus/0').send(jws)))
      .then(res => {
        assert.equal(res.status, 404);
        done();
      })
      .catch(done);
  });

  it('rejects an update to an authz by the wrong key', (done) => {
    let server = new ACMEServer(serverConfig);
    let testServer = request(server.app);

    let challPath;
    jose.newkey()
      .then(k => k.thumbprint())
      .then(tpBuffer => {
        let thumbprint = jose.base64url.encode(tpBuffer);
        let existing = {
          id:         thumbprint,
          thumbprint: thumbprint,
          challenges: [null],
          type:       function() { return 'authz'; }
        };
        server.db.put(existing);

        challPath = `authz/${thumbprint}/0`;

        let nonce = server.transport.nonces.get();
        let url = `${server.baseURL}${challPath}`;
        return mockClient.makeJWS(nonce, url, {});
      })
      .then(jws => promisify(testServer.post(`/${challPath}`).send(jws)))
      .then(res => {
        assert.equal(res.status, 401);
        done();
      })
      .catch(done);
  });

  it('auto-issues if all challenges are valid', () => {});
});
